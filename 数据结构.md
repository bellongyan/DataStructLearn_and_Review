# 数据结构临死前的挣扎

---

## 概论

不考，但是复杂度还是很重要的

$O(c)<O(log_2n)<O(n)<O(n\log n)<O(n^2)< O(n^3)< O(2^n)< O(n!)< O(n^n)$

[算法复杂度分析](https://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html)

[常用的排序算法的时间复杂度和空间复杂度](https://www.cnblogs.com/angelye/p/7508292.html)

#### 概论例题

> ---
> 
> 例题1：
>
> ```C
>if ( A > B ) {
> for ( i=0; i<N*N/100; i++ )
>   for ( j=N*N; j>i; j-- )
>        A += B;
>    }
>    else {
> for ( i=0; i<N*2; i++ )
>   for ( j=N*3; j>i; j-- )
>        A += B;
>    }
>    ```
> 
> 求上述代码的时间复杂度
>
> 答案：$O(N^4)$
>
> ---
>
> 例题2：
>
> 数据在计算机内存中的表示是指：**==数据的存储结构==**
>
> ---
>
> 例题3：
>
> 在数据结构中，与所使用的计算机无关的数据结构是：**==逻辑结构==**
>
> ---
>
> 例题4：
>
> 以下关于数据结构的说法中正确的是:(1)
>
> 1. **==数据结构的逻辑结构独立于其存储结构==**
>2. 数据结构的存储结构独立于该数据结构的逻辑结构
> 3. 数据结构的逻辑结构唯一地决定了该数据结构的存储结构
> 4. 数据结构仅由其逻辑结构和存储结构决定

## 线性表

线性表主要是顺序表和链表

### 顺序表

> 顺序表的优缺点：
>
> 优点：
>
> 1. 空间利用率高，数据是连续存放，命中率比较高 
> 2. 存取速度高效，通过下标来直接访问。
>
> 缺点：
>
> 1. 插入和删除比较慢，在插入或者删除一个元素的时候，需要遍历整个顺序表移动前后的数据
> 2. 需要预先分配足够大的空间，估计的过大，会导致顺序表后的大量空间被闲置；但是估计的过小，又会造成溢出。 
>
> 时间复杂度 :查找操作为O(1) ,插入和删除操作为O(n)。

[顺序表（顺序存储结构）及初始化详解 (biancheng.net)](http://c.biancheng.net/view/3334.html)

[顺序表的基本操作（C语言详解版） (biancheng.net)](http://c.biancheng.net/view/3335.html)

#### 顺序表例题

> ---
>
> 例题1:
>
> 若长度为n的线性表采用顺序存储结构，那么删除它的第i个数据元素之前，需要它一次向前移动（**==$n-i$==**）个数据元素。
>
> ---
>
> 例题2:
>
> 对于顺序表，以下说法错误的是（ 1）
>
> 1. **==顺序表是用一维数组实现的线性表，数组的下标可以看成是元素的绝对地址==**
>2. 顺序表是用一维数组实现的线性表，数组的下标可以看成是元素的绝对地址
> 3. 顺序表的特点是:逻辑结构中相邻的结点在存储结构中仍相邻
> 4. 顺序表的特点是:逻辑上相邻的元素，存储在物理位置也相邻的单元中
> 
> ---
>
> 例题3:
>
> 在长度为n的顺序表的表尾插入一个新元素的时间复杂度为（**==$O(1)$==**）
>
> ---
>
> 

### 链表

> 优点：
> 1. 插入和删除速度快，保留原有的物理顺序，在插入或者删除一个元素的时候，只需要改变指针指向即可。
> 2. 没有空间限制,存储元素无上限,只与内存空间大小有关. 
> 3. 动态分配内存空间，不用事先开辟内存
> 4. 是内存的利用率变高
>
> 缺点：
> 1. 占用额外的空间以存储指针，比较浪费空间，不连续存储，malloc函数开辟空间碎片比较多)
> 2. 查找速度比较慢，因为在查找时，需要循环链表。
>
>  时间复杂度 :查找操作为O(n) ,插入和删除操作为O(1)。

#### 单链表

[什么是单链表，链式存储结构详解 (biancheng.net)](http://c.biancheng.net/view/3336.html)

[单链表的基本操作（C语言版） (biancheng.net)](http://c.biancheng.net/view/3338.html)

#### 链表例题

> ---
>
> 例题1：
>
> 以下关于链式存储结构的叙述中，（3）是不正确的。
>
> 1. 结点除自身信息外还包括指针域，因此存储密度小于顺序存储结构
> 2. 逻辑上相邻的结点物理上不必邻接
> 3. **==可以通过计算直接确定第i个结点的存储地址==**
> 4. 插入、删除运算操作方便，不必移动结点
>
> ---
>
> 例题2：
>
> 线性表 L 在什么情况下适用于使用链式结构实现？1
>
> 1. **==需不断对 L 进行删除插入==**
> 2. 需经常修改 L 中的结点值
> 3.  L 中含有大量的结点
> 4.  L 中结点结构复杂
>
> ---
>
> 例题3：
>
> 链表不具有的特点是:2
>
> 1. 插入、删除不需要移动元素
> 2. **==方便随机访问任一元素==**
> 3. 不必事先估计存储空间
> 4. 所需空间与线性长度成正比

## 栈和队列

> 相同点:
> 逻辑结构相同,都是线性的.都可以用顺序存储结构或链式存储结构.栈和队列是两种特10 / 54殊的线性表,即受限的线性表(只是对插入和删除运算加以限制).
> 
> 不同点:
> 
> 1. 运算规则不同,线性表是随机存取的,而栈是只允许在一端进行插入和删除运算的,因而是后进先出表 LIFO;队列是只允许在一端进行插入,另一端进行删除运算,因而是先进先出表 FIFO.
> 2. 用途不同,线性表比较通用,堆栈用亍函数调用,递归和筒化设计等.队列用于离散事件模拟,多道作业处理和筒化设计等.

### 栈

#### 顺序栈

[顺序栈及基本操作（包含入栈和出栈） (biancheng.net)](http://c.biancheng.net/view/3350.html)

#### 链栈

[链栈及基本操作（包含入栈和出栈）详解 (biancheng.net)](http://c.biancheng.net/view/3351.html)

#### 栈例题

> ---
>
> 例题1：
>
> 链式栈与顺序栈相比，一个比较明显的优点是（2 ）。
>
> 1. 插入操作更加方便
> 2. **==通常不会出现栈满的情况==**
> 3. 不会出现栈空的情况
> 4. 删除操作更加方便
>
> ---
>
> 例题2：
>
> 若$(a-b)*(c+d)$是中序表达式，则其后序表达式是（ ）
>
> 1. $abcd+*-*$
> 2. **==$ab-cd+*$==**
> 3. $ab-*cd+*$
> 4. $a-bcd+*$
>
> ---
>
> 例题3：
>
> 字符A,B,C依次进入一个栈,按出栈的先后顺序组成不同的字符串,则至多可以组成( )个不同的字符串。
>
> 1. $14$
> 2. **==$5$==**
> 3. $6$
> 4. $8$
>
> ---
>
> 例题4：
>
> 下列算法的功能是（2）。
>
> ```C
> void func( )
> {
>       int x;
>       Statck s;    //定义栈s
>       cin >> x;
>       while (x<>0)
>       {
>          push(s,x);
>          cin>>x;
>        }
>       while (!EmptyStack(s))
>           cout << pop(s);
>  }
> ```
>
> 1. 以读入数据的相同顺序输出数据
> 2. **==以读入数据的相反顺序输出数据==**
> 3. 将数据读入到栈中进行保存
> 4. 读入一批数据到栈中进行求和并输出
>
> ---
>
> 例题5：
>
> 若已知一个栈的进栈序列是$1，2，3，...，n，$其输出序列为$p1，p2，p3，...，pn，$若$p1 = 3$，则$p2$为（1）。
>
> 1. 可能是2
> 2. **==一定是2==**
> 3. 可能是1
> 4. 一定是1
>
> ---
>
> 例题6：
>
> 若 `top` 为指向栈顶元素的指针，判定栈 `S` （最多容纳 `m` 个元素）为空的条件是：若 `top` 为指向栈顶元素的指针，判定栈 `S` （最多容纳 `m` 个元素）为空的条件是：2
>
> 1. `S->top == 0`
> 2. **==`S->top == -1`==**
> 3. `S->top != m-1`
> 4. `S->top == m-1`
>
> ---
>
> 例题7：
>
> 给定一个堆栈的入栈序列为${ 1, 2, ⋯, n }$，出栈序列为${ p_1, p_2, ⋯, p_n }$。如果$p2=n$，则存在多少种不同的出栈序列？
>
> 1. $n$
> 2. **==$n−1$==*
> 3. $2$
> 4. $1$

### 队列

#### 顺序队列

[顺序队列及C语言实现（2种方案） (biancheng.net)](http://c.biancheng.net/view/3353.html)

#### 链式队列

[链式队列及基本操作（C语言实现） (biancheng.net)](http://c.biancheng.net/view/3354.html)

#### 队列例题

> ---
>
> 例题1：
>
> 在用数组表示的循环队列中，front值一定小于等于rear值。**==F==**
>
> ---
>
> 例题2：
>
> 环形队列中有多少个元素可以根据队首指针和队尾指针的值来计算。**==T==**
>
> ---
>
> 例题3：
>
> 在一个不带头结点的非空链式队列中,假设 f 和 r 分别为队头和队尾指针,则插入 s 所指的结点运算是( 2)。
>
> 1. `f->next=s; f=s;`
> 2. **==`r->next=s; r=s;`==**
> 3. `s->next=s; r=s;`
> 4. `s->next=s; r=s;`
>
> ---
>
> 例题5：
>
> 设一个循环队列 `Q[maxSize]`的队头指针为 `front` ，队尾指针为 `rear` ，队列最大容量为 `maxSize` ，此外该队列再没有其他数据成员，则队列的队满条件是（ 3）。
>
> 1. `Q.front == Q.rear`
> 2. `Q.front+Q.rear >= maxSize`
> 3. **==`Q.front == (Q.rear +1) % maxSize`==**
> 4. `Q.rear == (Q.f ront+1) % maxSize`
>
> ---
>
> 例题6：
>
> 循环队列的队空条件为（4 ）
>
> 1. `(sq.rear+1) % mazsize ==(sq.front+1) % maxsize;`
> 2. `(sq.rear+1)% maxsize ==sq.front+1`
> 3. `(sq.rear+1) % maxsize ==sq.front`
> 4. **==`sq.rear ==sq.front`==**
>
> ---
>
> 例题7：
>
> 循环队列 3。
>
> 1. 不会产生溢出
> 2. 不会产生上溢出
> 3. **==不会产生假溢出==**
> 4. 以上都不对
>
> ---
>
> 例题8：
>
> 在少用一个元素空间的循环队列(m为最大队列长度)是满队列的条件（ 2）
>
> 1. `rear==front`
> 2. **==`(rear+1)%m==front`==**
> 3. `(rear+1)==front`
> 4. `front==(front+1)%m`

---
---


## 树

从这一章开始难度急剧上升

个人认为不会直接考察树的知识点，但是会重点考察二叉树，但是树的一些概念还是需要知道的

[数据结构的树存储结构 (biancheng.net)](http://c.biancheng.net/view/3383.html)

[什么是二叉树（包含满二叉树和完全二叉树） (biancheng.net)](http://c.biancheng.net/view/3384.html)

### 二叉树顺序存储结构

[二叉树的顺序存储结构（看了无师自通） (biancheng.net)](http://c.biancheng.net/view/3385.html)

### 二叉树链式存储结构

[二叉树的链式存储结构（C语言详解） (biancheng.net)](http://c.biancheng.net/view/3386.html)

### 二叉树的四种遍历（非递归方法不考察）

[二叉树先序遍历（递归与非递归）及C语言实现 (biancheng.net)](http://c.biancheng.net/view/3388.html)

[二叉树中序遍历（递归和非递归）算法C语言实现 (biancheng.net)](http://c.biancheng.net/view/3389.html)

[二叉树后序遍历（递归与非递归）算法C语言实现 (biancheng.net)](http://c.biancheng.net/view/3390.html)

[二叉树层次遍历（包含C语言实现代码） (biancheng.net)](http://c.biancheng.net/view/3392.html)

### 哈夫曼树

[哈夫曼树（赫夫曼树、最优树）详解 (biancheng.net)](http://c.biancheng.net/view/3398.html)

## 图

图和树的联系挺紧密的

图的一些概念

[数据结构的图存储结构 (biancheng.net)](http://c.biancheng.net/view/3404.html)

[什么是连通图，（强）连通图详解 (biancheng.net)](http://c.biancheng.net/view/3405.html)

[什么是生成树，生成树（生成森林）详解 (biancheng.net)](http://c.biancheng.net/view/3406.html)

### 图的几种存储结构

图的存储里面要理解好邻接矩阵、邻接表的概念，以及怎么存储的

[图的顺序存储结构（包含C语言实现） (biancheng.net)](http://c.biancheng.net/view/3407.html)

[图的邻接表存储结构详解 (biancheng.net)](http://c.biancheng.net/view/3408.html)

[图的十字链表存储结构 (biancheng.net)](http://c.biancheng.net/view/3409.html)

[图的邻接多重表存储结构 (biancheng.net)](http://c.biancheng.net/view/3410.html)

### 图的搜索

[深度优先搜索（DFS、深搜）和广度优先搜索（BFS、广搜） (biancheng.net)](http://c.biancheng.net/view/3411.html)

[深度优先生成树和广度优先生成树（详解版） (biancheng.net)](http://c.biancheng.net/view/3412.html)

### 最小生成树的算法

这个链接里面是纯代码的 $\to$ [最小生成树（prime算法、kruskal算法） 和 最短路径算法（floyd、dijkstra） - 爱也玲珑 - 博客园 (cnblogs.com)](https://www.cnblogs.com/aiyelinglong/archive/2012/03/26/2418707.html)

这是带有图解的，便于理解的链接 $\to$ [最小生成树-Prim算法和Kruskal算法 - as_ - 博客园 (cnblogs.com)](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html)

## 查找

## 内排序

这里面也都是内排序的纯代码 $\to$ [内排序 - 博园少主 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wc1903036673/p/3499076.html)

各种排序的算法复杂度 $\to $ [常用的排序算法的时间复杂度和空间复杂度](https://www.cnblogs.com/angelye/p/7508292.html)

---
---

最后，如果我说的东西没考到，不要怪我，因为我也不是老师，我也不晓得波波会出什么题目呜呜呜呜呜呜呜呜呜